# HTML

## DOCTYPE 的作用

```
<!DOCTYPE> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档，一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式来进行解析，在标准模式下，浏览器的解析规则都是按照最新的标准来进行解析的，而在兼容模式下，浏览器会以向后兼容的模式来模拟老式浏览器的行为，以保证一些老的网站的正确访问

在HTML5之后不再需要指定DTD文档，因为html5之前的html文档都是基于SGML的，所以需要通过指定DTD来定义文档中允许的属性以及一些规则，而html5不再基于SGML了，所以不再需要使用DTD
```

## 标准模式与兼容模式各有什么区别

```
标准模式的渲染方式和js引擎的解析方式都是以该浏览器支持的最高标准运行的，在兼容模式，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作
```

## HTML5为什么只需要写(\<!DOCTYPE HTML\>),而不需要引入DTD

```
HTML5不是基于SGML,因此不需要对DTD进行引用，但是需要 DOCTYPE 来规范浏览器的行为
而 HTML4.01 基于 SGML 所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型
```

## DTD介绍

```
DTD（Document Type Definition 文档类型定义）是一组机器可读规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义，在解析网页时，浏览器将使用这些规则检查页面的有效性，并且采取相应的措施。
DTD是对HTML文档得声明，还会影响浏览器的渲染模式
```

## HTML语义化

```
html语义化就是让页面内容结构化，它有如下优点：
1.易于用户阅读，样式丢失的时候能让页面呈现清晰的结构
2.有利于seo，搜索引擎根据标签来确定上下文和各个关键字的权重
3.方便其他设备解析，如盲人阅读器根据语义渲染网页
4.有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐

举例
<header> 代表头部
<nav> 代表超链接区域
<main> 定义文档主要内容
<article> 表示文章，博客等内容
<aside> 侧边栏或嵌入内容
<footer> 代表尾部
```

## HTML新标签

```
<header> <footer> <aside> <section> <nav> <video> <audio> <canvas>
```

## 行内元素和块级元素

```
行内元素（display:inline)
宽度与高度有内容决定，和其它元素共占一行,设置 margin 和 padding 的上下不会对其他元素产生影响 <span> <a> <i> <img> <strong> <sub> <sup> <input> <label> <select> <textarea>
块级元素（display:block)
默认宽度由父容器决定，默认高度由内容决定，独占一行且可以设置宽高，<div> <p> <ul> <ol> <li> <h...>

行内块元素(display:inline-block)
既具有block的宽高特性，又具有inline的同行特性

```

## 空元素的定义

```
标签内没有内容的HTML标签被称为空元素，空元素是在开始标签中关闭的
常见的空元素 br hr img input link meta
```

## link标签的定义

```
link 标签定义文档与外部资源的关系
link 元素是空元素，仅包含属性，此元素只能存在head 部分，不过它可出现任何次数
link 标签中的rel属性定义当前文档与被链接文档之间的关系，常见的 stylesheet 指定加载一个外部定义的样式表
```

## link与@import

```
1.从属关系区别，@import 是css提供的语法规则，只具有导入样式表的作用，link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性、引入网站图标等。
2.加载顺序区别，加载页面时，link标签引入的css被同时加载，@import引入的css在页面加载完毕后被加载
3.兼容性区别，@import 是CSS2.1采样的语法，只可在IE5+才能识别，link标签作为HTML元素，不存在兼容性问题
4.DOM可控性区别，可以通过js操作DOM，插入link标签来改变样式，由于DOM方法是基于文档的，无法使用@import的方式插入样式
```

## 对浏览器的理解

```
浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF，image及其他格式，用户用URI（Uniform Resource Identifier 统一资源标识父)来指定请求资源的位置
HTML和CSS规范中规定html文档的方式，由W3c组织对这些规范进行维护，W3C是负责制定web标准的组织
浏览器可以分为两个部分，shell和内核，其中shell的种类比较多，内核比较少，shell是指浏览器的外壳，例如菜单，工具栏等，主要是提供给用户界面操作，参数设置等等，它是调用内核来实现各种功能的，内核才是浏览器的核心，内核是基于标记语言显示内容的程序或模块。
```

## 对浏览器内核的理解

```
主要分成两个部分：渲染引擎和js引擎
渲染引擎负责渲染
js引擎负责解析和执行JavaScript来实现网页的动态效果
```

## 浏览器的渲染原理

```
1.首先解析收到的文档，根据文档定义构建一颗DOM树，DOM树是由DOM元素及属性节点组成的
2.对CSS进行解析，生成CSSOM规则树
3.根据DOM树和CSSOM规则树构建渲染树，渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM元素相对应，但这种对应关系不是一对一的，不可见的DOM元素不会被插入渲染树，还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述
4.当渲染对象被创建并添加到渲染树中，它们并没有位置和大小，所以当浏览器生成渲染树后，就会根据渲染树来进行布局，也称回流，然后浏览器要弄清各个节点在页面中的确切位置和大小，也被称为自动重排
5.布局阶段结束后开始绘制，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件
```

## 渲染过程中遇到JS文件怎么处理

```
javascript 的加载，解析，与执行会阻塞文档的解析，也就是说，在构建DOM时，HTML解析器若是遇到了JAVAScript，那么会暂停文档的解析，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复继续解析文档
也就是说，如果你想首屏渲染的越快，就越不应该在首屏加载js文件，建议将 script标签放在body标签底部
```

## 前端需要注意哪些SEO

```
1.合理的title、description、keywords：搜索对这三项的权重逐渐减小，title值强调重点即可，重要关键词不要超过两次，而且要靠前，不同页面title要有所不同，description把页面内容高度概括，不可过分堆砌关键词，不同页面的description有所不同，keywords列举出重要关键词即可
2.语义化的HTML代码，符合W3c规范，语义化代码让搜索引擎更容易理解网页
3.重要的HTML代码放在最前，搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制
4.重要内容不要用js输出，爬虫不会执行js获取内容
5.少用 iframe：搜索引擎不会抓取iframe中的内容
6.非装饰性图片必须加alt
7.提高网站速度
```

## cookies,sessionStorage,localStorage的区别

```
cookie 最开始是服务端用于记录用户状态的一种方式，由服务端设置，在客户端存储，然后每次发起同源请求时，发送给服务端，cookie最多只能存储4k数据，它的生存时间由expires属性指定，并且cookie只能被同源的页面访问到

sessionStorage 是html5提供的一种浏览器本地存储的方法，它借鉴了服务端session的概念，代表的是一次会话中所保存的数据，它一般能够存储5M或更大的数据，它在当前窗口关闭后就失效了，并且sessionStorage只能被同一个窗口的同源页面所访问共享

localStorage 也是html5提供的一种浏览器本地存储方法，它一般也能够存储5M或更大的数据，它和sessionStorage不同的是除非手动删除它，否则它不会失效，并且localStorage也只能被同源页面所访问共享
```

## Label的作用，怎么使用

```
label标签用来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上

```

## HTML5的表单自动完成功能

```
autocomplete 属性规定输入字段是否应该启用自动完成功能，默认为启用，设置 autocomplete=off 可以关闭该功能
自动完成允许浏览器预测对字段的输入，当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项
```

## 渐进增强和优雅降级的定义

```
渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验
优雅降级：一开始就根据高版本浏览器构建完整功能，然后再针对低版本浏览器进行兼容
```

## css reset 和 normalize.css 有什么区别

```
 css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成画蛇添足的效果。

 后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。
```

## 主流浏览器内核私有属性css前缀

```
mozilla内核 （firefox，flock) -moz
webkit内核（safari，chrome)-webkit
opera内核 （opera浏览器）-o
trident内核 （ie浏览器）-ms

```





# CSS

## 盒子模型

```
盒模型有标准盒模型(content-box),和IE盒模型(border-box)
盒模型都由四个部分组成：margin,border,padding,content
通过box-sizing 可以修改元素的宽度
如果值为 content-box 元素的宽度 = style( width + margin + border + padding)
如果值为 border-box 元素的宽度 = style(width)

```

## rem与em的区别

```
rem是根据根标签的font-size计算，假如<html>的font-size:12px 那么 2rem 就是 24px
em 是根据父元素的font-size计算, 加入元素的父元素font-size:12px 那么该元素的2em 就是24px
```

## CSS常用选择器

```
id选择器（#myid)
类选择器（.myClassName)
标签选择器（div,p,span)
后代选择器（div p)
相邻后代选择器,即直接后代，儿子（ul>li)
兄弟选择器 （li~a)
相邻兄弟选择器（li+a)
属性选择器（a[rel="external"])
伪类选择器（a:hover)
伪元素选择器（::before)
通配符选择器（*）

css选择器的权重
!important > 行内样式 > #id > .class > 元素和伪元素 > * > 继承 > 默认
```

## ::before 和 :before 中双冒号有什么区别

```
单冒号用于css3伪类，双冒号用于css3伪元素，双冒号是在当前规范中引入的用于区分伪类和伪元素，不过浏览器需要同时支持旧的已存在的伪元素写法，而新的在css3中引入的伪元素则不允许再支持旧的单冒号写法
```

## css中哪些属性可以继承

```
每一个属性自定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，继承父元素的同属性值来作为自己的值，
一般具有继承性的属性有字体相关的属性 font-size，font-weight,文本相关的属性，color，text-align等，表格的一些布局属性，列表属性如list-style,光标属性cursor，元素可见性visibility
当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。
```



## CSS3新特性

```
transition: 过渡
transform: 选择，缩放，移动，倾斜
animation: 动画
gradient 渐变
shadow: 阴影
border-radius 圆角
```

## position relative 与 absolute 的区别

```
position:absolute 绝对定位，相对于元素最近的已经定位的祖先元素，通常指被relative修饰
position:relative 相对定位，相对于自身在文档中的初始位置

```

## CSS中visibility属性中的collapse属性的作用，不同浏览器的区别

```
1.对于一般元素，它的表现和visibili：hidden是一样的，元素不可见，但是任然会占用页面的空间
2.如果元素是和table相关的元素，例如table行，它的表现和display：none一样，也就是说，它们占用的空间会释放

在谷歌浏览中，使用collapse和hidden没有什么区别
在火狐浏览器，opera，IE11中，使用collapse效果与display：none一样
```

## width:100%与width:auto的区别

```
width:100% 会使元素box的宽度等同于父元素content box的宽度
width:auto 回使元素撑满整个父元素，margin，border、padding、content区域也会自动分配水平空间
```

## 绝对定位元素与非绝对定位元素的百分比计算区别

```
绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的
非绝对元素的宽高百分比相对于父元素的content box来计算的
```



## BFC

```
什么是BFC:
	块级格式化上下文，它是一个独立的渲染区域，让处于BFC内部的元素和外部的元素相互隔离，使内外元素的定位不会	互相影响
如何产生BFC:
	display:inline-block
	position:absolute
	position:fixed
	float:left/right
BFC的作用
	在页面上有一个独立的隔离容器，容器内的元素和容器外的元素布局不会互相影响
	解决上外边距重叠，重叠的两个box都开启bfc
	解决浮动引起的高度坍塌，容器盒子开启bfc
	解决文字环绕图片，左边图片div,右边容器p，将容器p开启bfc

```

## IFC是什么？

```
IFC指的是行级格式化上下文，它有这样的布局规则：
1.行级上下文内部的盒子在水平方向上，一个接一个的放置
2.当一行bu够的时候会自动切换到下一行
3.行级上下文的高度有内部最高的内联盒子的高度决定
```

## margin和padding分别适用什么场景适用

```
margin是用来隔开元素与元素的间距，padding是用来隔开元素与内容的间距
margin布局分开元素时元素互不相干
padding用于元素与内容之间的间隔，让内容与元素之间有一定间距

何时用到margin：
需要在border外侧添加白色、
空白处不需要背景、
上下相连的两个盒子之间的空白需要相互抵消

何时使用到padding：
需要在border内侧添加空白
空白处需要背景
上下相连的两个盒子之间的空白，希望等于两者之和时
```

## 元素的竖向百分比设定是相对于容器的高度吗？

```
如果是height的话，是相对于包含块的高度
如果是marign或padding的竖直方向属性，是相对于包含块的宽度
```

## 设备像素、css像素、设备独立像素、dpr、ppi直接的区别

```
设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的
css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，相对于设备像素，一个css像素的大小取决于页面缩放程度和dpr的大小
dpr是指设备像素和设备独立像素的比值，
ppi指的是每英寸的物理像素密度，ppi越大，屏幕的分辨率越大
```

## 什么是Cookie隔离

```
网站向服务器发起请求时，会自动的带上cookie这样的表头信息，使数据请求变慢
将静态资源放在其它域名中
```

## style标签写在body后与body前有什么区别

```
页面加载自上而下当然是先加载样式，写在body标签后由于浏览器以逐行的方式对HTML文档进行解析，当解析写在尾部的样式会导致浏览器停止之前的渲染，等待加载且解析样式完毕之后重新渲染，写在windows的IE下可能会出现页面闪烁
```

## 什么是css预处理器

```
CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。

预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。

CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后
处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。

后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
```

## 什么是cssSprite

```
将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。

优点：
减少HTTP请求数，极大地提高页面加载速度
增加图片信息重复度，提高压缩比，减少图片大小
更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

缺点：
图片合并麻烦
维护麻烦，修改一个图片可能需要重新布局整个图片，样式
```

## 使用rem布局的优缺点

```
优点：
在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。
而且现在浏览器基本都已经支持rem了，兼容性也非常的好。

缺点：
（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。
（2）使用iframe引用也会出现问题。
（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。
```



## less sass styus三者区别

```
变量：
sass声明变量用$开头,冒号连接变量名与值，less用@开头，冒号连接变量名与值，stylus 声明变量变量名与值用等号
嵌套：
在选择器嵌套上面没有任何区别，连引用父级选择器的标记&也相同
继承：
sass和Stylus的继承非常像，能把一个选择器中的所有样式继承到另外一个选择器上，使用@extend+选择器
less 使用伪类来描述继承关系 :extend(选择器)
导入:
sass中只能在使用url()表达式引入时进行变量差值
$device:mobile
@import url(styles.#{$device}.css);
less可以在字符串中进行差值
@device:mobile;
@import "style.@{device}.css"
Stylus 中使用字符串拼接字符串
device="mobile"
@import "styles."+device+".css";
```

## CSS优先级

```
判断优先级时，首先判断一条属性是否声明了 !important，如果有，它的优先级最高，然后是行内样式，id选择器，类选择器，伪类选择器和属性选择器，之后是元素选择器和伪元素选择器，最后是*
```

## transition和animation的区别

```
transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。
animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。
```

## 内联盒模型基本概念

```
（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。

（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。

（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。

（4）包含块（containing box），由一行一行的“行框盒子”组成。
```

## margin:auto 的填充规则

```
margin的'auto'可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。
（1）如果一侧定值，一侧auto，则auto为剩余空间大小。
（2）如果两侧均是auto，则平分剩余空间。
```

## css中不同属性设置为百分比对应的计算基准

```
公式：当前元素某CSS属性值 = 基准 * 对应的百分比
元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width
元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width
元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width
元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）
元素的 border-width，不支持百分比
元素的 text-indent，基准为包含块的 width

元素的 border-radius，基准为分别为自身的height、width
元素的 background-size，基准为分别为自身的height、width
元素的 translateX、translateY，基准为分别为自身的height、width
元素的 line-height，基准为自身的 font-size

元素的 font-size，基准为父元素字体
```



# JS

## JS数据类型

```
基本数据类型
String Number Boolean Null Undefined Symbol,BigInt
复杂数据类型
Object 
```

## JavaScript有几种类型的值，内存如何分配

```
js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。
基本数据类型有String Number Boolean Null Undefined Symbol,BigInt
复杂数据有Object类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。
两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。
```

## 什么是堆，什么是栈？它们之间有什么区别

```
堆和栈的概念存在于数据结构中和操作系统内存中。

在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。

在操作系统中，内存被分为栈区和堆区。

栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。
```

## 内部属性[[class]]是什么？

```
所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非
传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..)
Object.prototype.toString.call( [1,2,3] );
// "[object Array]"

Object.prototype.toString.call( /regex-literal/i );
// "[object RegExp]"

// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签
// 默认情况类的[[Class]]返回[object Object]
class Class1 {}
Object.prototype.toString.call(new Class1()); // "[object Object]"
// 需要定制[[Class]]
class Class2 {
  get [Symbol.toStringTag]() {
    return "Class2";
  }
}
Object.prototype.toString.call(new Class2()); // "[object Class2]"
```

## js的内置对象

```
js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。
```

## undefined 与 undeclared区别

```
已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。
对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 "undefined"。
```

## null和undefined的区别

```
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。

undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
```

## 如何获取安全的undefined值

```
因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。

表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。

按惯例我们用 void 0 来获得 undefined。

```



## 闭包

```
介绍：
函数A中包含了函数B，函数B使用了函数A的变量，函数B就是闭包，或者，能够读取其他函数内部变量的函数
特征：
函数内在嵌套函数
背部函数应用了外层的参数和变量
参数和变量不会被垃圾回收
闭包的好处:
能够实现封装和缓存
闭包的坏处:
消耗内存，不正当的使用会导致内存泄露
```

## 原型和原型链

```
介绍：
每个对象都会在其内部初始化一个属性，就是prototype(原型) 当我们访问一个对象的属性时，如果对象的内部不存在这个属性，就会在prototype里找这个属性，这个prototype又会有自己的prototype ，于是一直向上找
原型和原型链的关系(相等)
instance.constructor.prototype = instance.__proto__

JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
```

## js获取原型的方法

```
p.__proto__
p.constructor.prototype
Object.getPrototypeOf(p)
```

## js中不同进制数字的表示方式

```
以 0X、0x 开头的表示为十六进制。
以 0、0O、0o 开头的表示为八进制。
以 0B、0b 开头的表示为二进制格式。
```

## js中整数的安全范围是多少

```
安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，
即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。

如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。
```

## Typeof Nan的结果是什么

```
NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出
数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

typeof NaN; // "number"

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。
```

## isNan 和 Number.isNaN的区别

```
函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。

函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。
```

## Array 构造函数只有一个参数值时的表现

```
Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。

构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。
```

## 其它值转为字符串的转换规则

```
（1）Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，

（2）Boolean 类型，true 转换为 "true"，false 转换为 "false"。

（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。

（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。

（5）对普通对象来说，除非自行定义 toString() 方法，否则会调toString（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。
```

## 其它值转为数字值的转换规则

```
（1）Undefined 类型的值转换为 NaN。

（2）Null 类型的值转换为 0。

（3）Boolean 类型的值，true 转换为 1，false 转换为 0。

（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。

（5）Symbol 类型的值不能转换为数字，会报错。

（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。

如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。
```

## 其它值转换成布尔值的规则

```
ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。

以下这些是假值：
• undefined
• null
• false
• +0、-0 和 NaN
• ""

假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。
```

##  {} 和 [] 的 valueOf 和 toString 的结果是什么？

```
{} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

[] 的 valueOf 结果为 [] ，toString 的结果为 ""
```

## 什么是假值对象？

```
浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。
```

## ~ 操作符的作用?

```
~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。

~x 大致等同于 -(x+1)。
```

## 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？

```
解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。
```

## `+` 操作符什么时候用于字符串的拼接？

```
简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。
```

## 什么情况下会发生布尔值的隐式强制类型转换？

```
（1） if (..) 语句中的条件判断表达式。
（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
（3） while (..) 和 do..while(..) 循环中的条件判断表达式。
（4） ? : 中的条件判断表达式。
（5） 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
```

##  || 和 && 操作符的返回值？

```
|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。

对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。

&& 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果
```

## Symbol 值的强制类型转换？

```
ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。

Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。
```

## == 操作符的强制类型转换规则？

```
（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。

（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。

（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。

（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。

（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。

（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
```

##  如何将字符串转化为数字，例如 '12.3b'?

```
（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。

（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。

（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。

（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。
```

## 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?

```
// 方法一
function format(number) {
  return number && number.replace(/(?!^)(?=(\d{3})+\.)/g, ",");
}
// 方法二
function format1(number) {
  return Intl.NumberFormat().format(number)
}
// 方法三
function format2(number) {
  return number.toLocaleString('en')
}
```



## 解决异步回调地狱

```
promise 
generator
async/await
```

## This的理解

```
this总是指向函数的直接调用者
使用 call bind apply 可以修改指向
```

# Vue

## Vue生命周期

```
介绍：Vue实例从创建到销毁的过程
生命周期钩子函数：
beforeCreate,created,beforeMount,mounted,beforeUpdate,updated,activated,deactivated,beforeDestory,destoryed,errorCaptured
```

## v-show 与 v-if

```
v-show 是css切换 display:none;
v-if 是真正的销毁与重建

```







